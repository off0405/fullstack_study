<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    // 1. ... 스프레드(spread) 연산자
    // 스프레드 문법을 사용하면 
    // 배열의 경우) 요소가 예상되는 위치 또는 (함수 호출의 경우)인자값을 넣는 위치에서
    // 배열 또는 문자열과 같은 반복 가능 항목을 확장할 수 있습니다.
    // 객체의 경우) 객체의 속성을 열거하고 생성 중인 객체에 키-값 쌍을 추가합니다.
    
    // 결론: 객체의 요소를 펼친다

    // 1) 배열의 결합
    const veggie = ['토마토', '오이', '콩'];
    const meat = ['돼지고기', '소고기', '닭고기'];

    const menu = [...veggie, '파스타', ...meat];
    console.log(menu);
    
    
    // 2) 배열의 복사
    const newVeggie = veggie;

    newVeggie.push('완두콩');
    console.log(newVeggie);
    console.log(veggie); // 원본까지 같이 변경됨
    // 실제로 복사본을 만든 것이 아니라, 새 배열은 단순히 이전 배열을 참조하기 때문

    // ES5에서 일반적으로 배열의 복사본을 만드는 방법
    const originveggie = ['토마토', '오이', '콩'];
    const copyveggie = [].concat(originveggie);
    copyveggie.push('완두콩');
    console.log(copyveggie);
    console.log(originveggie); // 원본은 변경 안됨

    // ES6에서 스프레드 문법으로 배열의 복사본을 만드는 방법
    const copyBeggieES6 = [...originveggie]; // originveggie의 모든 요소를 펼쳐서 넣음
    copyBeggieES6.push('완두콩ES6');
    console.log(copyBeggieES6);
    console.log(copyveggie);

    
    // 3) 함수와 스프레드 연산자
    // 인자값들을 요소로 가지는 배열에 스프레드 연산자를 사용하면 함수를 쉽게 호출 가능
    function doStuff(x, y, z) {
      console.log(x + y + z);
    }
    const args = [0, 1, 2];
    doStuff(args); // 매개변수 x에 args 배열(0, 1, 2)이 할당됨, y와  z는 undefined
    doStuff(...args);

    // 다른 예
    const name = ['Goni', 'Kim'];

    function greet(first, last) {
      console.log(`Hello ${first} ${last}`);
    }
    greet(...name);

    //지정된 매개변수보다 더 많은 값을 제공하면..?
    const otherName = ['Goni', 'Kim', 'goni'];
    greet(...otherName); // 마지막 값은 어디에도 할당되지 않고 안쓰임

    //활용) 최대값 구하기
    const numbers = [22, 55, 50, 80, 90];
    const max = Math.max(...numbers);
    console.log(max);
    
    
    
    // 4) 객체 리터럴과 스프레드(ES2080부터 객체에도 적용됨)
    // 4-1) 객체의 복사
    const person = {
      name: 'Goni',
      surname: 'Kim',
      age: 30
    }

    const clone = {
      ...person
    };
    
    console.log(clone);

    clone.age = 15
    console.log(clone);
    console.log(person); // 원본은 변경 안됨
    
    
    // 4-2) 객체의 결합
    const teacher = {
      name: 'JH Kim',
      age: 30
    };
    
    
    // 기존 객체에 새로운 속성을 추가하여 새로운 객체 정의
    const classInfo1 = {
      ...teacher,
      subject: 'Web Full Stack'
    };
    console.log(classInfo1);
    
    const classInfo2 = {
      ...classInfo1,
      day: 'weekday'
    }
    
    console.log(classInfo2);
    
    //2. ...레스트(rest, 나머지) 연산자
    // 생긴 것은 스프레드 연산자와 동일하지만 기능적으로 정반대
    // 스프레드는 '확장(펼치다)'하는 반면, 레스트는 나머지 여러 요소를 하나의 요소로 '압축'
    
    // 1) 배열과 레스트
    const runner = ['Kim', 'Lee', 'Park', 'Choi'];
    const [] = runner;
    const [first, second, ...losers] = runner; // 레스트 연산자로 압축
    
    console.log(losers);
    console.log(...losers); //함수 호출의 경우 스프레드 연산자로 쓰임

    // 2) 함수의 레스트 파라미터
    function sum(...args) {
      let sum = 0;
      for (const arg of args) {
        sum += arg;
      }
      return sum;
    }
    console.log(sum (4, 5, 16, 25, 100));
    
    // 3) 객체 리터럴과 레스트(ES2018부터 객체에도 적용됨)
    const myObj = {
      a: 1, 
      b: 3,
      c: 5, 
      d: 7, 
      e: 9
    }

    // 레스트 연산자를 사용하여 a,b를 제외한 나머지 속성을 변수 z에 할당
    const { a, b, ...z } = myObj;
    console.log(a);
    console.log(b);
    console.log(z);
    

        // Quiz 
    // 9.1 배열의 값을 확장하기 위한 스프레드의 올바른 문법은? 3
    
    // 1) [.]
    // 2) (...)
    // 3) [...]
    // 4) {...}

    // 9.2 다음 작업을 수행하는 코드를 작성하자.
    // 다음과 같이 배열 colors가 주어졌을 때, 
    // 처음 2개는 순서대로 mainColor, backgroundColor라는 변수에 할당하고
    // 처음 2개 이후의 모든 값을 포함하는 themes라는 새 배열을 생성하자.
    const colors = ['royalblue', 'gray', 'yellow', 'indigo', 'green'];

    const [mainColor, backgroundColor, ...themes] = colors

    


    // 9.3 다음 코드의 올바른 출력은?  3
    const arr = [1, 2, 3, 4];
    const arr2 = arr;

    arr2.push(5);
    console.log(arr);

    // 1) [1, 2, 3, 4]
    // 2) [1, 2, 4, 5]
    // 3) [1, 2, 3, 4, 5]
    // 4) "1, 2, 3, 4, 5"
  </script>
  
</head>
<body>
  
</body>
</html>